# Voice_Diary


![Экран авторизации](https://user-images.githubusercontent.com/73352665/160488006-22d9a43f-c562-493c-a0b9-b2730325eef0.jpg)         ![Диалог сохранения записи](https://user-images.githubusercontent.com/73352665/160488361-fbe6d420-ec50-4131-ad87-a42bc8125343.jpg)


![Экран записей](https://user-images.githubusercontent.com/73352665/160488492-d1f0b488-cbd9-43fa-919a-365174df51c0.jpg)         ![Экран настроек](https://user-images.githubusercontent.com/73352665/160488494-14b5450c-31fe-417d-a28e-9ee892a7a6dc.jpg)

## Реализация

### Баги в последней версии
К моменту окончания дедлайна я очень спешил и поэтому не тестировал последние изменения должным образом, в итоге я несколькими последними коммитами породил как минимум 3 бага:

 * Баг с крашем при повороте экрана во время записи аудиособщения
 * Баг с отображением в списке записей текущего записываемого сообщения
 * Баг с неправильным отображением кнопок play/stop у записи, после того, как MediaPlayerService был убит в бэкграунде

Оба бага я заметил утром, 29.03.2022 и пофиксил в отдельной ветке, чтобы последний коммит в main был до окончания дедлайна:

 * [Фикс бага с крашем при поворотах](https://github.com/andreyhoco/Voice_Diary/commit/a7421dc2ffff427cc8612d84cf53046ead9bdbb6)
 * [Фикс бага с отображением записываемого аудио](https://github.com/andreyhoco/Voice_Diary/commit/e74f8ed94a4610dff68fe3e418d304fa426ab9f0)
 * [Фикс бага с отображением кнопок play/start](https://github.com/andreyhoco/Voice_Diary/commit/c033bc166b01cb5bde39c366e680d7fd1c908c4f)

### Реализованный функционал
К сожалению, я не успел реализовать все фичи, которые хотел (такие уж выпали выходные). Однако, почти весь основной функционал был реализован:

 * **Запись аудиосообщений:** запись аудио реализована с помощью Bound Service, который содержит MediaRecorder, это позволяет продолжать запись при поворотах экрана, а при дальнейшем развитии приложения позволит использовать запись в Foreground;
 * **Отображение записанных аудиосообщений:** записанные аудиосообщения отображаются в списке, помимо названия записи также доступна информаци о дате записи;
 * **Воспроизведение аудиосообщений:** воспроизведение реализовано также с помощью Bound Service, однако он уже содержит MediaPlayer, что также позволяет продолжать воспроизведение при поворотах экрана и также является отправной точкой для воспроизведения в Foreground.

    Однако здесь я не реализовал 2 вещи: 
    * Постановка на паузу и продолжение воспроизведения аудио c момента паузы;
    * Отображение длительности аудио и текущего статуса воспроизведения (на какой секунде сейчас находится воспроизводиоме аудио).
 * **Авторизация в VK с помощью VK SDK:** реализована авторизация в VK, кроме того пользоваться приложением можно и без авторизации, в этом случае предполагалось, что пользователю не будет доступна загрузка аудио в VK Документы, однако данный функционал я не реализовал.

    Также доступен экран настроек, на котором можно:
    * Включить пропуск экрана авторизации;
    * Авторизоваться через VK;
    * Выйти из учетной записи VK;
    * (Преполагалось) Загрузить документы в VK.

### Основные компоненты приложения

#### MainActivity
Предназначена для авторизации в VK или продолжения без нее. Является точкой входа в приложение. Если пользователь авторизован или в настройках установлен флаг "Пропускать экран авторизации", то данный экран "пропускается" и стартует HostActivity.

![MainActivity](https://user-images.githubusercontent.com/73352665/160592545-91dd9878-9e2e-4a68-8d41-a2490d3a9d8b.jpg)

#### HostActivity
Является хостом для фрагментов, то есть применяется подход SingleActivity. Также запрашивает разрешения и выполняет базовую обработку результатов запроса, "общается" с фрагментами с помощью FragmentResultApi.

#### RecordsFragment
Ключевой экран в приложении. На нем отображаются аудиозаписи пользователя, с помощью него начинаются и завершаются воспроизведение и запись аудио. Для организации данного экрана применяется подход MVVM, поэтому для данного фрагмента существует RecordsViewModel, речь о которой пойдет ниже.

![RecordsFragment](https://user-images.githubusercontent.com/73352665/160595105-95d855fd-f555-4d75-a14e-008e56d4c95f.jpg)

При сохранении аудио пользователю предлагается ввести имя для данной записи. Это происходит с помощью BottomSheetDialogFragment. Если пользователь пропустит данный диалог, то файл будет сохранен с именем по умолчанию.

![BottomSheetDialogFragment](https://user-images.githubusercontent.com/73352665/160595562-16d04c3f-37b5-43f8-8327-029fc6bfcdd0.jpg)

Также с данного экрана можно перейти на экран настроек - то есть перейти к SettingsFragment. Если это сделать во время записи аудио, то пользователь увидит диалог с предупреждением о прекращении записи. В случае подтверждения перехода на экран настроек текущая запись будет сохранена с именем по умолчанию, если пользователь останется на текущем экране, то запись будет продолжена.

![AlertDialog](https://user-images.githubusercontent.com/73352665/160596879-b70fd056-b777-4de7-80b0-75d712791efd.jpg)

#### SettingsFragment
Экран настроек приложения. Здесь можно отключить экран авторизации, авторизоваться в учетную запись VK, выйти из учетной записи VK, и, как изначально предполагалось, перейти к загрузке документов в VK, однако реализовать данный функционал я не успел.

![SettingsFragment](https://user-images.githubusercontent.com/73352665/160597299-089dfa28-c882-4791-92f4-3f19e5857f63.jpg)

#### RecordService
Данный сервис предназначен для записи аудио и содержит MediaRecorder. Данный сервис является как Started, так и Bound. Это связано с 2 моментами:

 * клиент у сервиса всего 1 - RecordsFragment, поэтому при повороте экрана и пересоздании фрагмента у сервиса не остается клиентов и он уничтожается;
 * для работы MediaRecorder требуется разрешение пользователя на запись аудио с микрофона, поэтому запускать данный сервис можно только после получения соответствующего разрешения.

Bind к сервису происходит в коллбэке onStart фрагмента RecordsFragment, но только при наличии разрешения на запись аудио, unbind - в коллбэке onStop.

StartService вызывается же в следующих случаях:

 * после получения разрешения на запись аудио, в ActivityResultCallback;
 * в onResume фрагмента RecordsFragment, если разрешение получено, а до этого отсутствовало (в этом случае также вызывается и bindService). Я добавил такое поведение, из-за того, что предполагаю, что ActivityResultCallback может сработать после onResume;
 * в onViewCreated фрагмента RecordsFragment, если разрешение получено. Используется onViewCreated, а не onCreate, так как в случае возвращения по бэкстэку из фрагмента, который был запущен с помощью replace RecordsFragment, коллбэк onCreate вызван не будет.

Если у сервиса более 5 секунд (естественно время настриваемое) нет клиентов, то он уничтожается.

#### MediaPlayerService
Данный сервис предназначен для воспроизведения аудио и содержит MediaPlayer. Он также является и Started, и Bound. Все из-за наличия лишь 1 клиента.

StartService вызывается в onViewCreated фрагмента RecordsFragment, по тем же причинам, что и описаны выше (при возвращении после replace onCreate не вызывается, так как уничтожается только View фрагмента). 

Bind и unbind происходят в onStart и onStop соответственно.

Если у сервиса более 5 секунд (естественно время настриваемое) нет клиентов, то он уничтожается.

#### FileManager
FileManager, а точнее класс, реализующий интерфейс FileManager, предназначен для инкапсуляции механизмов работы с файлами и файловой системой.

С его помощью можно получить:

 * сгенерированное имя по умолчанию для аудиозаписи;
 * путь в файловой системе к сохраненным аудиозаписям;
 * сохраненные аудиозаписи;
 * переименовать сохраненную аудиозапись (реализован механизм защиты от изменения существующего файла с таким же именем );
 * удалить аудиозапись.

Его реализация - FileManagerImpl существует в единственном экземпляре и предоставляется с помощью "DI на коленке" (из application класса).

#### RecordsViewModel
Является ViewModel для RecordsFragment. Хранит и передает с помощью LiveData:

 * состояние записи аудио - **isRecording**;
 * отображаемые аудиозаписи - **records**;
 * путь для сохраняемой аудиозаписи - **newRecordPath**;
 * проигрываемую в текущий момент аудиозапись - **playingRecord**;

Также содержит ряд методов для изменения этих данных.
Главное, что необходимо рассказать про RecordsViewModel - это механизм управления воспроизводимой записью и её отображением. Он состоит в следующем:

 1. Пользователь нажимает на кнопку play или pause некоторой записи.
 2. Срабатывает clickListener, а внутри него лямбда onPlayClicked, которая передает во ViewModel объект Record текущей записи, со значием true в поле isPlaying.
 3. ViewModel анализирует пришедший объект Record:
    * если объект равен currentPlayingRecord - то ничего не делать;
    * если объект равен null (сброс или окончание воспроизведения), то необходимо отправить в records новый список, в котором у всех записей поле isPlaying будет равно false;
    * если объект отличается от currentPlayingRecord только значением поля isPlaying, то необходимо отправить в records новый список, в котором записи с соответствующим объектом значение isPlaying будет равно значению isPlaying полученного объекта;
    * если объект отличается от currentPlayingRecord, то необходимо отправить в records новый список, в котором для записи, соответствующей currentPlayingRecord значение isPlaying будет равно false, а для записи соответствующей полученному объекту значение isPlaying будет равно значению isPlaying объекта.

Кроме того, после срабатывания OnCompletionListener MediaPlayer`a, то есть после завершения воспроизведения, во viewModel будет передан null, что является оповещением об окончании воспроизведения.

Значение поля isPlaying того или иного объекта класса Record позволяет определить в адаптере  - какую кнопку (play или pause) нужно отображать и для какого элемента.

Помимо этого при обработке viewModel`ю объекта Record, он также сохраняется в currentPlayingRecord и передается внутрь liveData playingRecord. Объект liveData playingRecord обсервит RecordsFragment, при получении нового значения происходит следующая обработка:

 * если значение равно null - вызвать stop у MediaPLayerService (внутри сервиса находится защита от вызова stop в неактуальном состоянии MediaPLayer);
 * если поле **MediaPlayerService.isPlaying** равно false, то начать воспроизведение, иначе - прекратить воспроизведение; 
